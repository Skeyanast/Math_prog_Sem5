<p align="center">
  <img src="https://www.mirea.ru/upload/medialibrary/c1a/MIREA_Gerb_Colour.jpg" alt="MIREA" width="80"/>
  <img src="https://www.mirea.ru/upload/medialibrary/26c/FTI_colour.jpg" alt="IPTIP" width="137"/> 
</p>

# Математика для программирования (часть 1/2) [I.24-25]

---

**Студент:**  
**Муравьев Иван Вадимович**

**Место обучения:**  
**Москва, Институт РТУ МИРЭА**  
**Факультет ИПТИП**  
**Кафедра Индустриального программирования**

**Направление:**  
**Фулстек разработка**

**Группа:**  
**ЭФБО-02-22**

**Шифр:**  
**22Т0240**

**Преподаватель:**  
**Клёсов Дмитрий Николаевич**

**Семестр:**  
**5 семестр, 2024-2025 гг.**

---

## Практическое задание

Задачи:
1. Разработать лабиринт и задать начальную и конечную точки движения объекта.
2. Реализовать алгоритмы поиска пути (например, A*, Dijkstra, волновой алгоритм) для нахождения оптимального пути в лабиринте.
3. Сравнить траекторию движения объекта с теоретически оптимальным маршрутом, предсказанным математической моделью.
4. Оценить эффективность движения: измерить и проанализировать время прохождения, длину пути и количество шагов.

Задание реализовано в приложении на WinForms на языке программирования C#. Для измерения времени работы методов алгоритмов поиска пути в программе используется класс Stopwatch из стандартной библиотеки System.Diagnostics.

### Скриншоты работы

Лабиринт №1: Алгоритм Дейкстры
<p align="center">
  <img src="https://github.com/user-attachments/assets/ff1bce98-ca56-4814-80f3-ac364ab9f650" alt="Лабиринт №1: Алгоритм Дейкстры" width="800"/>
</p>

Лабиринт №1: Алгоритм A*
<p align="center">
  <img src="https://github.com/user-attachments/assets/aab26ba1-4fa2-46a9-bdc2-51100960234d" alt="Лабиринт №1: Алгоритм A*" width="800"/>
</p>

Лабиринт №1: Алгоритм Ли (волновой алгоритм)
<p align="center">
  <img src="https://github.com/user-attachments/assets/e25df0a9-f793-4820-aa7e-93518705a92c" alt="Лабиринт №1: Алгоритм Ли (волновой алгоритм)" width="800"/>
</p>

Лабиринт №2: Алгоритм Дейкстры
<p align="center">
  <img src="https://github.com/user-attachments/assets/4deffba4-c036-4e01-90d1-086db6643232" alt="Лабиринт №2: Алгоритм Дейкстры" width="800"/>
</p>

Лабиринт №2: Алгоритм A*
<p align="center">
  <img src="https://github.com/user-attachments/assets/0ffd5e28-a09a-4814-ae05-bdda4c2d145b" alt="Лабиринт №2: A*" width="800"/>
</p>

Лабиринт №2: Алгоритм Ли (волновой алгоритм)
<p align="center">
  <img src="https://github.com/user-attachments/assets/4ef733b0-1d70-4fd4-9443-f2ab7c45362f" alt="Лабиринт №2: Алгоритм Алгоритм Ли (волновой алгоритм)" width="800"/>
</p>

Лабиринт №3: Алгоритм Дейкстры
<p align="center">
  <img src="https://github.com/user-attachments/assets/b13b0a63-1def-496a-a15c-e35af4bde94b" alt="Лабиринт №3: Дейкстры" width="800"/>
</p>

Лабиринт №3: Алгоритм A*
<p align="center">
  <img src="https://github.com/user-attachments/assets/83b3e41b-73ce-4ba2-a807-42b69f2242c9" alt="Лабиринт №3: Алгоритм A*" width="800"/>
</p>

Лабиринт №3: Алгоритм Ли (волновой алгоритм)
<p align="center">
  <img src="https://github.com/user-attachments/assets/a012769d-9471-42e3-824a-297fe3539277" alt="Лабиринт №3: Алгоритм Алгоритм Ли (волновой алгоритм)" width="800"/>
</p>

### Выводы

1. Модельный путь практически во всех ситуациях соответствует кратчайшему пути из возможных.
2. Производительность алгоритмов вычислена посредством десяти запусков программы и вычислением среднего арифметического значения времени работы алгоритма в миллисекундах, тесты проводились на лабиринте 10x10 клеток. Результаты:
  - Алгоритм Дейкстры - 3.6 ms;
  - Алгоритм A* - 10.1 ms;
  - Алгоритм Ли - 2.6 ms.
По результатам тестов производительности от двух других явно отстает алгоритм A*, скорее всего реализация оказалась слишком тяжеловесной, разницу можно увидеть даже на сетке столь малой размерности.
4. Для поиска пути в двумерном пространстве (сетке) на мой взгляд лучше всего использовать алгоритм Ли (волновой алгоритм) или его модификации, так как он довольно легковесный и относительно прост в реализации.

### Ответы на вопросы

1. Как можно адаптировать алгоритмы для более сложных лабиринтов с динамическими изменениями?
  - Если лабиринт изменяется, необходимо периодически проверять текущее состояние пути. Например, если появляется новая стена или исчезает старая, алгоритм заново запустит поиск, начиная с текущего положения.
  - Использовать подход, при котором можно быстро обновлять стоимость пути. Если наблюдаются изменения, можно использовать механизм «учета ранее пройденного пути», чтобы минимизировать вычисления и пересчитывать только затронутые области.

2. Каким образом учитываются изменения в скорости объекта или непредсказуемые препятствия?

  - В алгоритме A* и алгоритме Дейкстры можно использовать различные веса для разных типов местности. Например, если на некотором участке скорость объекта уменьшается (из-за препятствия или другого фактора), нужно будет увеличить стоимость этого пути.
  - Если есть перемещающиеся препятствия, можно использовать методы предсказания, чтобы определить, где препятствие окажется в следующую секунду. С учетом этого можно заранее откорректировать маршрут.
  - Можно разделить перемещения объектов на временные фреймы и учитывать скорость, направление и предсказуемость окружающей среды. Если цель движется, алгоритмы должны учитывать это изменение в динамической среде.

---

## Контакты

Если у вас есть вопросы или предложения, пожалуйста, свяжитесь со мной:

- **[Email](mailto:muravev.i.v@edu.mirea.ru)** <img src="https://www.svgrepo.com/show/452213/gmail.svg" alt="Email Icon" width="20"/>
- **[GitHub](https://github.com/Skeyanast)** <img src="https://www.svgrepo.com/show/475654/github-color.svg" alt="GitHub Icon" width="20"/>

---

**Муравьев Иван Вадимович**  
**Москва, Институт РТУ МИРЭА**
